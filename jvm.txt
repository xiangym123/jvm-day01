垃圾：没有任何引用指向的  一个对象或者多个对象（循环）就是垃圾
引用计数
跟可达算法  
跟对象 必须的对象   静态变量  常量池  jni指针

清除算法:Mark-Sweep：特点：算法简单，效率低 产生碎片  适用于存活对象比较多的情况
复制




1、什么是辣鸡（对比c、c++）？怎么找到辣鸡（引用计数/可达性分析）？
1.1、可达性分析是啥？
1.2、可达性分析的GC-root包括什么(class类对象、JVM栈、本地方法栈、类静态引用、运行时常量池)
2、辣鸡算法有啥（标记清除、标记整理、复制、分代算法）？
2.1、标记清除怎么做（标记可用对象，清除不可用对象）？标记清除的好处（算法简单）？标记清除的坏处（碎片、效率低下）？应用场景（适合对象存活较多的地方-old）？
2.2、复制怎么做（空间分一半，找到可用对象并移动到另一侧，清理掉原侧）？复制的好处（效率较高，没有碎片）？复制的坏处（改变引用，空间减半）？应用场景？（对象存活较少的地方，复制较少-young）
2.3、标记整理怎么做（标记可用对象，第二次把可用对象挪到前面）？标记整理的好处（没有碎片）？标记整理的坏处（改变引用，效率较低）?适用场景？（存活对象较多的地方-old）
2.4、分代算法，
2.4.1、堆空间结构：年轻代：young（eden、s0、s1）、老年代：old
2.4.2、年轻代：复制算法，eden/s0/s1区空间满了，触发gc，eden区辣鸡和s0辣鸡通过找到存活对象，移动到s1，如此类推，多次移动后，会转移到老年代
2.4.3、老年代：标记清除/整理算法
3、辣鸡回收器？
3.1、辣鸡回收器有啥？
3.1.1、年轻代：serial、parNew、ParllelScavenge
3.1.2、老年代：cms、serialOld、ParllelOld
3.2、垃圾回收器的配合？
3.2.1、serial可以和cms、serialOld
3.2.2、parNew可以和cms、serialOld
3.2.3、ParllelScavenge可以和serialOld、ParllelOld
3.2.4、cms如果没有配置好，会使用serialOld收集器
3.3、各辣鸡回收器：
3.3.1、serial单线程年轻代，会发生STW，在safePoint标记、回收辣鸡，复制算法，效率较高
3.3.2、ParllelScavenge多线程年轻代，会发生STW，在safePoint标记、回收辣鸡，复制算法，更加关注吞吐量
3.3.3、parNew多线程年轻代，会发生STW，在safePoint标记，回收辣鸡，复制算法，能更好与CMS配合使用
3.3.4、serialOld单线程老年代，会发生STW，在safePoint标记、回收辣鸡，标记整理算法
3.3.5、ParllelOld多线程老年代，会发生STW，在safePoint标记、回收辣鸡，标记整理算法
3.3.6、cms多线程并发老年代，会有以下过程，[1]、标记存活对象；[2]、并发标记；[3]、再次标记；[4]、并发清除，会有浮动辣鸡产生
3.3.7、补充辣鸡收集器：G1(100ms)、ZGC(10ms)、shenandoah(1ms)
3.3、gc种类及目标
3.3.1、youngGC,fullGC
3.3.2、优化目标：减少full GC